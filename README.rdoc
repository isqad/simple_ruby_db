== Поиск по объектам в памяти

В данном примере применен алгоритм бинарного дерева поиска (простого, с рекурсивным поиском и вставками).
Примерная оценка поиска в лучшем случае - lgN, в худшем 4N

=== Использование

  $ irb

  > require './db'

  > db = Db.new

  > db.search({'age.gt' => 20, 'age.lt' => 30})

  => <...results...>

  > db.search({'amount.lt' => 100})

  => {7825=>{:age=>78, :amount=>71.56201323055278, :height=>50, :weight=>83}} # Example output

  > db.search({:age => 25, :height => 180})

  => <...results...>

Вы можете комбинировать условия выборки. Всего условий в данном примере 4:

* age - возраст
* amount - зарплата
* weight - вес
* height - рост

Для поиска по диапозону добавьте к ключу выборки .lt (меньше чем) или .gt (больше чем).

=== Возможное улучшение

Здесь применено простое бинарное дерево поиска для каждого поля (строятся индексы для каждого из 4-х)
В худшем случае, одно либо несколько индексов будут не сбалансированными, и на необходимо будет произвести N обходов
(для каждого).
Альтернативным решением будет преобразовать класс BinaryTree в красно-черное дерево для гарантии обхода за lgN раз.
(Красно-черное дерево или 2-3 дерево "сохраняет" идеальный баланс при вставке последовательных ключей,
то есть растояние от корня до любых "нулевых" узлов одно и тоже).
